#!/usr/bin/env ruby
#
# BioRuby vcf plugin 
# Author:: Pjotr Prins
#
# Copyright (C) 2014 Pjotr Prins <pjotr.prins@thebird.nl>

USAGE = "Vcf parser"

gempath = File.dirname(File.dirname(__FILE__))
$: << File.join(gempath,'lib')

VERSION_FILENAME=File.join(gempath,'VERSION')
version = File.new(VERSION_FILENAME).read.chomp

require 'bio-vcf'
require 'optparse'

# Uncomment when using the bio-logger 
# require 'bio-logger'
# log = Bio::Log::LoggerPlus.new 'vcf'
# log.outputters = Bio::Log::Outputter.stderr 
# Bio::Log::CLI.logger('stderr')
# Bio::Log::CLI.trace('info')

options = { show_help: false}
opts = OptionParser.new do |o|
  o.banner = "Usage: #{File.basename($0)} [options] filename\ne.g.  #{File.basename($0)} < test/data/input/somaticsniper.vcf"

  o.on('-i','--ignore-missing', 'Ignore missing data') do 
    options[:ignore_missing] = true
  end
  o.on('--filter cmd',String, 'Evaluate filter on each record') do |cmd|
    options[:filter] = cmd
  end
  o.on('--sfilter cmd',String, 'Evaluate filter on each sample') do |cmd|
    options[:sfilter] = cmd
  end
  o.on("--sfilter-samples list", Array, "Filter on selected samples") do |l|
    options[:sfilter_samples] = l
  end
  o.on('-e cmd', '--eval cmd',String, 'Evaluate command on each record') do |cmd|
    options[:eval] = cmd
  end
  o.on('--eval-once cmd',String, 'Evaluate command once (usually for header info)') do |cmd|
    options[:eval_once] = true
    options[:eval] = cmd
  end
  o.on('--seval cmd',String, 'Evaluate command on each sample') do |cmd|
    options[:seval] = cmd
    options[:skip_header] = true
  end
  o.on("--rewrite eval", "Rewrite INFO") do |s|
    options[:rewrite] = s
  end
  o.on("--samples list", Array, "Output selected samples") do |l|
    options[:samples] = l
  end
  o.on("--rdf", "Generate Turtle RDF") do |b|
    require 'bio-vcf/vcfrdf'
    options[:rdf] = true
    options[:skip_header] = true
  end
  o.on_tail("--id name", String, "Identifier") do |s|
    options[:id] = s
  end
  o.on_tail("--tags list", String, "Add tags") do |s|
    options[:tags] = eval(s)
  end
 
  # Uncomment the following when using the bio-logger 
  # o.separator ""
  # o.on("--logger filename",String,"Log to file (default stderr)") do | name |
  #   Bio::Log::CLI.logger(name)
  # end
  #
  # o.on("--trace options",String,"Set log level (default INFO, see bio-logger)") do | s |
  #   Bio::Log::CLI.trace(s)
  # end
  # 
  o.on("-q", "--quiet", "Run quietly") do |q|
    # Bio::Log::CLI.trace('error')
    options[:quiet] = true
  end
   
  o.on("-v", "--verbose", "Run verbosely") do |v|
    options[:verbose] = true
  end
  
  # o.on("--debug", "Show debug messages") do |v|
  #   Bio::Log::CLI.trace('debug')
  # end

  o.separator ""
  o.on_tail('-h', '--help', 'display this help and exit') do
    options[:show_help] = true
  end
end


def parse_line line,header,options,samples
    # fields = VcfLine.parse(line,header.columns)
    fields = VcfLine.parse(line)
    rec = VcfRecord.new(fields,header)
    r = rec # alias
    if !options[:filter] or (options[:filter] and rec.eval(options[:filter],options[:ignore_missing],options[:quiet]))
      # -----------------------------
      # Filtering and set analysis
      if options[:sfilter]
        rec.each_sample(options[:sfilter_samples]) do | sample |
          return if not sample.eval(options[:sfilter],options[:ignore_missing],options[:quiet])
        end
      end
      # -----------------------------
      # From here on decide on output
      if samples
        # Select certain samples for output
        newfields = fields[0..8]
        samples.each do |s|
          newfields << fields[s+9] 
        end
        fields = newfields
      end
      if options[:eval] 
        begin
          res = rec.eval(options[:eval],options[:ignore_missing],options[:quiet])
          print res,"\n" if res
        rescue 
          $stderr.print "Line: ",line
          $stderr.print "ERROR evaluating --eval <"+options[:eval]+">\n"
          raise if options[:verbose]
          exit 1
        end
        exit(1) if options[:eval_once]
      elsif options[:seval]
        list = [rec.chr,rec.pos]
        rec.each_sample(options[:sfilter_samples]) do | sample |
          list << sample.eval(options[:seval],options[:ignore_missing],options[:quiet])
        end
        print list.join("\t"),"\n"
      else
        if options[:rdf]
          # Output Turtle RDF
          if not header_out
            VcfRdf::header
            header_out = true
          end
          VcfRdf::record(options[:id],rec,options[:tags])
        elsif options[:rewrite]
          # Default behaviour prints VCF line, but rewrite info
          eval(options[:rewrite]) 
          print (fields[0..6]+[rec.info.to_s]+fields[8..-1]).join("\t"),"\n"
        else
          # Default behaviour prints VCF line
          print fields.join("\t"),"\n"
        end
      end
    end
end

include BioVcf

opts.parse!(ARGV)

$stderr.print "vcf #{version} (biogem Ruby #{RUBY_VERSION}) by Pjotr Prins 2014\n" if !options[:quiet]

if options[:show_help] 
  print opts 
  print USAGE
  exit 1
end

$stderr.print "Options: ",options,"\n" if !options[:quiet]

if options[:samples]
  samples = options[:samples].map { |s| s.to_i }
end
header = VcfHeader.new
header_out = false
line_number=0

STDIN.each_line do | line |
  line_number += 1
  $stderr.print '.' if line_number%100_000 == 0 and not options[:quiet]
  begin
    if line =~ /^##fileformat=/
      # ---- We have a new file header
      header = VcfHeader.new
      header.add(line)
      print line if not options[:skip_header]
      STDIN.each_line do | headerline |
        if headerline !~ /^#/
          line = headerline
          break # end of header
        end
        header.add(headerline)
        if not options[:skip_header]
          if headerline =~ /^#CHR/
            selected = header.column_names
            if samples
              newfields = selected[0..8]
              samples.each do |s|
                newfields << selected[s+9] 
              end
              selected = newfields
            end
                  
            print "#",selected.join("\t"),"\n"
          else
            print headerline
          end
        end
      end
    end
    next if line =~ /^##/ # empty file
    # ---- Parse VCF record line
    parse_line line,header,options,samples
  rescue Exception => e
    $stderr.print line
    $stderr.print e.message
    raise if options[:verbose]
    exit 1
  end
end


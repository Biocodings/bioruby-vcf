#!/usr/bin/env ruby
#
# BioRuby vcf plugin 
# Author:: Pjotr Prins
#
# Copyright (C) 2014 Pjotr Prins <pjotr.prins@thebird.nl>

USAGE = "Vcf parser"

gempath = File.dirname(File.dirname(__FILE__))
$: << File.join(gempath,'lib')

VERSION_FILENAME=File.join(gempath,'VERSION')
version = File.new(VERSION_FILENAME).read.chomp

require 'bio-vcf'
require 'optparse'
require 'timeout'

# Uncomment when using the bio-logger 
# require 'bio-logger'
# log = Bio::Log::LoggerPlus.new 'vcf'
# log.outputters = Bio::Log::Outputter.stderr 
# Bio::Log::CLI.logger('stderr')
# Bio::Log::CLI.trace('info')

options = { show_help: false}
opts = OptionParser.new do |o|
  o.banner = "Usage: #{File.basename($0)} [options] filename\ne.g.  #{File.basename($0)} < test/data/input/somaticsniper.vcf"

  o.on('-i','--ignore-missing', 'Ignore missing data') do 
    options[:ignore_missing] = true
  end
  o.on('--filter cmd',String, 'Evaluate filter on each record') do |cmd|
    options[:filter] = cmd
  end

  o.on('--sfilter cmd',String, 'Evaluate filter on each sample') do |cmd|
    options[:sfilter] = cmd
  end
  o.on("--sfilter-samples list", Array, "Filter on selected samples") do |l|
    options[:sfilter_samples] = l
  end

  o.on('--ifilter cmd','--if cmd',String, 'Include filter') do |cmd|
    options[:ifilter] = cmd
  end
  o.on("--ifilter-samples list", Array, "Include set - implicitely defines exclude set") do |l|
    options[:ifilter_samples] = l
  end

  o.on('--efilter cmd','--ef cmd',String, 'Exclude filter') do |cmd|
    options[:efilter] = cmd
  end
  o.on("--efilter-samples list", Array, "Exclude set - overrides exclude set") do |l|
    options[:efilter_samples] = l
  end

  o.on('-e cmd', '--eval cmd',String, 'Evaluate command on each record') do |cmd|
    options[:eval] = cmd
  end
  o.on('--eval-once cmd',String, 'Evaluate command once (usually for header info)') do |cmd|
    options[:eval_once] = true
    options[:eval] = cmd
  end
  o.on('--seval cmd',String, 'Evaluate command on each sample') do |cmd|
    options[:seval] = cmd
    options[:skip_header] = true
  end
  o.on("--rewrite eval", "Rewrite INFO") do |s|
    options[:rewrite] = s
  end
  o.on("--samples list", Array, "Output selected samples") do |l|
    options[:samples] = l
  end
  o.on("--rdf", "Generate Turtle RDF") do |b|
    require 'bio-vcf/vcfrdf'
    options[:rdf] = true
    options[:skip_header] = true
  end
  o.on("--use-threads", "Multi-core version") do |b|
    $stdout.sync = true
    options[:use_threads] = true
  end
  o.on_tail("--id name", String, "Identifier") do |s|
    options[:id] = s
  end
  o.on_tail("--tags list", String, "Add tags") do |s|
    options[:tags] = eval(s)
  end
 
  # Uncomment the following when using the bio-logger 
  # o.separator ""
  # o.on("--logger filename",String,"Log to file (default stderr)") do | name |
  #   Bio::Log::CLI.logger(name)
  # end
  #
  # o.on("--trace options",String,"Set log level (default INFO, see bio-logger)") do | s |
  #   Bio::Log::CLI.trace(s)
  # end
  # 
  o.on("-q", "--quiet", "Run quietly") do |q|
    # Bio::Log::CLI.trace('error')
    options[:quiet] = true
  end
   
  o.on("-v", "--verbose", "Run verbosely") do |v|
    options[:verbose] = true
  end
  
  # o.on("--debug", "Show debug messages") do |v|
  #   Bio::Log::CLI.trace('debug')
  # end

  o.separator ""
  o.on_tail('-h', '--help', 'display this help and exit') do
    options[:show_help] = true
  end
end

include BioVcf

def parse_header line, samples, options
  header = VcfHeader.new
  header.add(line)
  print line if not options[:skip_header]
  STDIN.each_line do | headerline |
    if headerline !~ /^#/
      line = headerline
      break # end of header
    end
    header.add(headerline)
    if not options[:skip_header]
      if headerline =~ /^#CHR/
        selected = header.column_names
        if samples
          newfields = selected[0..8]
          samples.each do |s|
            newfields << selected[s+9] 
          end
          selected = newfields
        end
        print "#",selected.join("\t"),"\n"
      else
        print headerline
      end
    end
  end
  return header,line
end

def parse_line line,header,options,samples
  fields = VcfLine.parse(line)
  rec = VcfRecord.new(fields,header)
  r = rec # alias

  filter = options[:filter]
  sfilter = options[:sfilter]
  efilter = options[:efilter]
  ifilter = options[:ifilter]
  seval = options[:seval]
  ignore_missing = options[:ignore_missing]
  quiet = options[:quiet]

  if sfilter or efilter or ifilter or seval
    # check for samples
    header_samples = header.column_names[9..-1]
    raise "Empty sample list, can not execute query!" if not header_samples
  end

  # --------------------------
  # Filtering and set analysis
  return if filter and not rec.filter(filter,ignore_missing,quiet)
  
  if sfilter
    rec.each_sample(options[:sfilter_samples]) do | sample |
      return if not sample.sfilter(sfilter,ignore_missing,quiet)
    end
  end

  if ifilter
    rec.each_sample(options[:ifilter_samples]) do | sample |
      return if not sample.ifilter(ifilter,ignore_missing,quiet)
    end
  end

  if efilter
    rec.each_sample(options[:efilter_samples]) do | sample |
      return if not sample.efilter(efilter,ignore_missing,quiet)
    end
  end

  # -----------------------------
  # From here on decide on output
  if samples
    # Select certain samples for output
    newfields = fields[0..8]
    samples.each do |s|
      newfields << fields[s+9] 
    end
    fields = newfields
  end
  if options[:eval] or seval
    begin
      results = nil # result string
      if options[:eval] 
        res = rec.eval(options[:eval],ignore_missing,quiet)
        results = res if res
      end
      if seval
        list = (results ? [] : [rec.chr,rec.pos])
        rec.each_sample(options[:sfilter_samples]) { | sample |
          list << sample.eval(seval,ignore_missing,quiet)
        }
        results = (results ? results + "\t" : "" ) + list.join("\t")
      end
    rescue => e
      $stderr.print "\nLine: ",line
      $stderr.print "ERROR evaluating --eval <#{options[:eval]}> #{e.message}\n"
      raise if options[:verbose]
      exit 1
    end
    print results,"\n" if results
    exit(1) if options[:eval_once]
  else
    if options[:rdf]
      # Output Turtle RDF
      if not header_out
        VcfRdf::header
        header_out = true
      end
      VcfRdf::record(options[:id],rec,options[:tags])
    elsif options[:rewrite]
      # Default behaviour prints VCF line, but rewrite info
      eval(options[:rewrite]) 
      print (fields[0..6]+[rec.info.to_s]+fields[8..-1]).join("\t")+"\n"
    else
      # Default behaviour prints VCF line
      $stdout.print fields.join("\t")+"\n"
      $stdout.flush
      return true
    end
  end
end

def parse_lines lines,header,options,samples
  if options[:use_threads]
    lines2 = lines.map { |l| l.clone }
    $stdout.flush
    fork do  # returns pid
      count_lines = 0
      $stdout.sync = true
      lines2.each do | line |
        count_lines +=1 if parse_line(line,header,options,samples)
      end
      $stderr.print "#{count_lines} lines written of #{lines2.size}\n"
      $stdout.flush
    end
  else
    lines.each do | line |
      parse_line line,header,options,samples
    end
  end
end

opts.parse!(ARGV)

$stderr.print "vcf #{version} (biogem Ruby #{RUBY_VERSION}) by Pjotr Prins 2014\n" if !options[:quiet]

if options[:show_help] 
  print opts 
  print USAGE
  exit 1
end

$stderr.print "Options: ",options,"\n" if !options[:quiet]

if options[:samples]
  samples = options[:samples].map { |s| s.to_i }
end
if not options[:efilter_samples] and options[:ifilter_samples]
  # Create exclude set as a complement of include set
  options[:efilter_samples] = header.column_names[9..-1].fill{|i|i.to_s}-options[:ifilter_samples]
end

header_out = false
header = nil
line_number=0
lines = []
pids = []

$stdout.sync = true

STDIN.each_line do | line |
  line_number += 1
  $stderr.print '.' if line_number%100_000 == 0 and not options[:quiet]
  begin
    if line =~ /^##fileformat=/
      header,line = parse_header line,samples,options
    end
    next if line =~ /^##/ # empty file
    lines << line
    if lines.size > 2_000
      $stderr.print line
      pids << parse_lines(lines,header,options,samples)
      lines = []
    end
  rescue Exception => e
    # $stderr.print line
    $stderr.print e.message,"\n"
    raise if options[:verbose]
    exit 1
  end
end


pids << parse_lines(lines,header,options,samples)
$stderr.print "Final pid=#{pids.last}, size=#{lines.size}\n"
lines = []

pids.each do |pid|
  $stderr.print "Waiting for pid=#{pid}\n"
  begin
    Timeout.timeout(10) do
      Process.wait
    end
  $stderr.print "OK pid=#{pid}\n"
  rescue Timeout::Error
    Process.kill 9, pid
    Process.wait pid
    $stderr.print "child killed, pid = #{pid}\n"
  end
end

